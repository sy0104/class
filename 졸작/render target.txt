RT는 쉐이더에서 그려준 결과물을 어디서 그려줄까를 얘기함, 어떤 대상에게 그릴 것이냐
하지만 경우에 따라서 우리가 출력하는 화면에 그리는 것 말고도
별도의 텍스처를 만들어서 그 버퍼에 그려주는 경우도 많다. ex) cctv

카메라가 찍고있는 환경 자체를 전체 화면에 그리는게 아니라 중간 단계를 거쳐서 어떤 텍스처라는 버퍼에다가 화면 결과를 그려준 다음에 실질적으로 테레비전에다가 우리가 그려준 텍스처를 입혀주면 cctv 기능을 만들 수 있다.

지금까지 사용하고 있던 forward 방식의 쉐이더는 낭비가 심하다는 문제가 있다
VS_Main에 있는 viewPos, viewNormal.. 이런 정보들은 vs에서 열심히 계산하기는 하지만
최종적으로 ps에 가서 그 정보를 활용해서 빛과 연산을 해서 컬러를 연산해주긴 하지만
결과적으로 최종 값인 색상 빼고 중간에 저장되어 있는 값들은 다 날아간다는 아쉬움이 있음

forward 방식에서 또하나의 문제는 빛 연산이 느리다는 점이다.
빛에 대한 모든 정보를 글로벌 버퍼(g_lightCount)에 넘겨준다음 그걸 포문을 돌면서 모든 빛에 대한 연산을 해줬다.
어떤 물체가 광원이 100개 있을 때, 이 물체가 해당 광원의 빛을 받을지 안받을지를 당장 알 길이 없기 때문에
for문을 돌면서 하나씩 연산을 해줄 수 밖에 없었다.

point light나 spot light는 영역이 있어, 그 영역만큼만 빛을 발산함에도 불구하고
모든 광원에 대해 하나씩 연산을 한다는 것은 심한 낭비이다.

요즘은 ui같은 제한적인 상황에서만 forward 방식을 사용하고, 대부분은 deferred 방식을 사용함

deferred 방식은 중간에 필요할것같은 모든 정보들을 다 저장함. 이 정보들 자체도 재사용할 수 있기 때문
FS(픽셀 셰이더)에서 빛과 관련된 연산을 당장 하지 않을 것임.
이 단계에서는 중간에 보존할만한 가치가 있는 데이터들을 RT에 그려준다.
최종적으로 모든 정보를 합쳐서 빛이나 기존에 있었던 물체들의 정보를 합해서 최종 결과물을 만든다.

이 방식의 가장 큰 장점은, 중간에 계산된 결과물에서 어떤 물체에 대한 정보를 텍스처에 기입하게 되면
해당 픽셀에 대해서 물체가 있는지 없는지를 판별할 수 있다.

forward 방식은 중간에 있던 모든 계산과정들이 손실되기 때문에 새로운 기법을 이용해서 어떤 이펙트를 만들고 싶을때
노멀 정보가 필요한다면 처음으로 돌릴수밖에 없음.

=> 당장 출력할 화면을 만들어주는 단계가 아니고, 텍스처에 내가 원하는 중간 정보를 저장한다 !

==================================================================================
1. deferred 셰이더 생성
지금까지는 단일 타겟으로 rt을 딱 하나만 사용했었음. 이제는 PS_OUT이라는 픽셀 셰이더의 출력 구조체를 만들어줌
PS_OUT을 보면 렌더타겟을 3개로 묶어서 한번에 건내주고 있음. 이것을 작업하기 위해 rt를 묶어서 관리하는 클래스 만들것임

2. RenderTargetGroup 클래스 생성
G_BUFFER - geometric buffer.
기하학적인 정보를 텍스처에다 기입한 후에 나중에 조립해서 렌더링하는게 deferred 렌더링, 그거에 대한 정보

3. Texture 클래스 수정
우리가 이미지 파일을 통해 로드하는 텍스처 뿐만 아니라 코드로(수동으로) 만들어주는 텍스처도 만들 수 있게 작업할 것임
-> deferred shader에 position, normal, color같은 애들을 받아주기 위한 새로운 버퍼를 만들어줘야 하기 때문(이미지 로드하는것보다 실시간으로 메모리에 만들어준게 더 편리함)
DepthStencilBuffer는 Texture 클래스를 통해 만들어줌
스왑체인의 버퍼, 리소스 자체, 한마디로 텍스처로 변환해서 관리하는 것은 텍스처 클래스에서 관리할 것임

4. Engine 클래스에 RenderTargetGroup array로 생성


